// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: logging.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "logging.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace tinynet {
namespace logging {

namespace {

const ::google::protobuf::Descriptor* LogMessageItem_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LogMessageItem_reflection_ = NULL;
const ::google::protobuf::Descriptor* LogOptions_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LogOptions_reflection_ = NULL;
const ::google::protobuf::Descriptor* LogReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LogReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* LogResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LogResp_reflection_ = NULL;
const ::google::protobuf::ServiceDescriptor* LoggingRpcService_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_logging_2eproto() {
  protobuf_AddDesc_logging_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "logging.proto");
  GOOGLE_CHECK(file != NULL);
  LogMessageItem_descriptor_ = file->message_type(0);
  static const int LogMessageItem_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogMessageItem, host_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogMessageItem, pid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogMessageItem, tid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogMessageItem, file_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogMessageItem, line_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogMessageItem, serverity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogMessageItem, msg_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogMessageItem, timestamp_),
  };
  LogMessageItem_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LogMessageItem_descriptor_,
      LogMessageItem::default_instance_,
      LogMessageItem_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogMessageItem, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogMessageItem, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LogMessageItem));
  LogOptions_descriptor_ = file->message_type(1);
  static const int LogOptions_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogOptions, logtostderr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogOptions, alsologtostderr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogOptions, colorlogtostderr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogOptions, stderrthreshold_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogOptions, log_prefix_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogOptions, logbuflevel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogOptions, logbufsecs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogOptions, minloglevel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogOptions, logfile_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogOptions, v_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogOptions, max_log_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogOptions, stop_logging_if_full_disk_),
  };
  LogOptions_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LogOptions_descriptor_,
      LogOptions::default_instance_,
      LogOptions_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogOptions, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogOptions, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LogOptions));
  LogReq_descriptor_ = file->message_type(2);
  static const int LogReq_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogReq, basename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogReq, items_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogReq, options_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogReq, flush_level_),
  };
  LogReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LogReq_descriptor_,
      LogReq::default_instance_,
      LogReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LogReq));
  LogResp_descriptor_ = file->message_type(3);
  static const int LogResp_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogResp, error_code_),
  };
  LogResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LogResp_descriptor_,
      LogResp::default_instance_,
      LogResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LogResp));
  LoggingRpcService_descriptor_ = file->service(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_logging_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LogMessageItem_descriptor_, &LogMessageItem::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LogOptions_descriptor_, &LogOptions::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LogReq_descriptor_, &LogReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LogResp_descriptor_, &LogResp::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_logging_2eproto() {
  delete LogMessageItem::default_instance_;
  delete LogMessageItem_reflection_;
  delete LogOptions::default_instance_;
  delete LogOptions_reflection_;
  delete LogReq::default_instance_;
  delete LogReq_reflection_;
  delete LogResp::default_instance_;
  delete LogResp_reflection_;
}

void protobuf_AddDesc_logging_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\rlogging.proto\022\017tinynet.logging\"\207\001\n\016Log"
    "MessageItem\022\014\n\004host\030\001 \001(\t\022\013\n\003pid\030\002 \001(\005\022\013"
    "\n\003tid\030\003 \001(\005\022\014\n\004file\030\004 \001(\t\022\014\n\004line\030\005 \001(\005\022"
    "\021\n\tserverity\030\006 \001(\005\022\013\n\003msg\030\007 \001(\t\022\021\n\ttimes"
    "tamp\030\010 \001(\003\"\231\002\n\nLogOptions\022\023\n\013logtostderr"
    "\030\001 \001(\010\022\027\n\017alsologtostderr\030\002 \001(\010\022\030\n\020color"
    "logtostderr\030\003 \001(\010\022\027\n\017stderrthreshold\030\004 \001"
    "(\005\022\022\n\nlog_prefix\030\005 \001(\010\022\023\n\013logbuflevel\030\006 "
    "\001(\005\022\022\n\nlogbufsecs\030\007 \001(\005\022\023\n\013minloglevel\030\010"
    " \001(\005\022\024\n\014logfile_mode\030\t \001(\005\022\t\n\001v\030\n \001(\005\022\024\n"
    "\014max_log_size\030\013 \001(\005\022!\n\031stop_logging_if_f"
    "ull_disk\030\014 \001(\010\"\215\001\n\006LogReq\022\020\n\010basename\030\001 "
    "\001(\t\022.\n\005items\030\002 \003(\0132\037.tinynet.logging.Log"
    "MessageItem\022,\n\007options\030\003 \001(\0132\033.tinynet.l"
    "ogging.LogOptions\022\023\n\013flush_level\030\004 \001(\005\"\035"
    "\n\007LogResp\022\022\n\nerror_code\030\001 \001(\0052M\n\021Logging"
    "RpcService\0228\n\003Log\022\027.tinynet.logging.LogR"
    "eq\032\030.tinynet.logging.LogRespB\003\200\001\001", 713);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "logging.proto", &protobuf_RegisterTypes);
  LogMessageItem::default_instance_ = new LogMessageItem();
  LogOptions::default_instance_ = new LogOptions();
  LogReq::default_instance_ = new LogReq();
  LogResp::default_instance_ = new LogResp();
  LogMessageItem::default_instance_->InitAsDefaultInstance();
  LogOptions::default_instance_->InitAsDefaultInstance();
  LogReq::default_instance_->InitAsDefaultInstance();
  LogResp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_logging_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_logging_2eproto {
  StaticDescriptorInitializer_logging_2eproto() {
    protobuf_AddDesc_logging_2eproto();
  }
} static_descriptor_initializer_logging_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int LogMessageItem::kHostFieldNumber;
const int LogMessageItem::kPidFieldNumber;
const int LogMessageItem::kTidFieldNumber;
const int LogMessageItem::kFileFieldNumber;
const int LogMessageItem::kLineFieldNumber;
const int LogMessageItem::kServerityFieldNumber;
const int LogMessageItem::kMsgFieldNumber;
const int LogMessageItem::kTimestampFieldNumber;
#endif  // !_MSC_VER

LogMessageItem::LogMessageItem()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tinynet.logging.LogMessageItem)
}

void LogMessageItem::InitAsDefaultInstance() {
}

LogMessageItem::LogMessageItem(const LogMessageItem& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tinynet.logging.LogMessageItem)
}

void LogMessageItem::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pid_ = 0;
  tid_ = 0;
  file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  line_ = 0;
  serverity_ = 0;
  msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  timestamp_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogMessageItem::~LogMessageItem() {
  // @@protoc_insertion_point(destructor:tinynet.logging.LogMessageItem)
  SharedDtor();
}

void LogMessageItem::SharedDtor() {
  if (host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete host_;
  }
  if (file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_;
  }
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_;
  }
  if (this != default_instance_) {
  }
}

void LogMessageItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LogMessageItem::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogMessageItem_descriptor_;
}

const LogMessageItem& LogMessageItem::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logging_2eproto();
  return *default_instance_;
}

LogMessageItem* LogMessageItem::default_instance_ = NULL;

LogMessageItem* LogMessageItem::New() const {
  return new LogMessageItem;
}

void LogMessageItem::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<LogMessageItem*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(pid_, tid_);
    ZR_(line_, serverity_);
    if (has_host()) {
      if (host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        host_->clear();
      }
    }
    if (has_file()) {
      if (file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        file_->clear();
      }
    }
    if (has_msg()) {
      if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        msg_->clear();
      }
    }
    timestamp_ = GOOGLE_LONGLONG(0);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LogMessageItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tinynet.logging.LogMessageItem)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string host = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_host()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->host().data(), this->host().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "host");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_pid;
        break;
      }

      // optional int32 pid = 2;
      case 2: {
        if (tag == 16) {
         parse_pid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pid_)));
          set_has_pid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_tid;
        break;
      }

      // optional int32 tid = 3;
      case 3: {
        if (tag == 24) {
         parse_tid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &tid_)));
          set_has_tid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_file;
        break;
      }

      // optional string file = 4;
      case 4: {
        if (tag == 34) {
         parse_file:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->file().data(), this->file().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "file");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_line;
        break;
      }

      // optional int32 line = 5;
      case 5: {
        if (tag == 40) {
         parse_line:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &line_)));
          set_has_line();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_serverity;
        break;
      }

      // optional int32 serverity = 6;
      case 6: {
        if (tag == 48) {
         parse_serverity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &serverity_)));
          set_has_serverity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_msg;
        break;
      }

      // optional string msg = 7;
      case 7: {
        if (tag == 58) {
         parse_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msg()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->msg().data(), this->msg().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "msg");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_timestamp;
        break;
      }

      // optional int64 timestamp = 8;
      case 8: {
        if (tag == 64) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tinynet.logging.LogMessageItem)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tinynet.logging.LogMessageItem)
  return false;
#undef DO_
}

void LogMessageItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tinynet.logging.LogMessageItem)
  // optional string host = 1;
  if (has_host()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->host().data(), this->host().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "host");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->host(), output);
  }

  // optional int32 pid = 2;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->pid(), output);
  }

  // optional int32 tid = 3;
  if (has_tid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->tid(), output);
  }

  // optional string file = 4;
  if (has_file()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->file().data(), this->file().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "file");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->file(), output);
  }

  // optional int32 line = 5;
  if (has_line()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->line(), output);
  }

  // optional int32 serverity = 6;
  if (has_serverity()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->serverity(), output);
  }

  // optional string msg = 7;
  if (has_msg()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->msg().data(), this->msg().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "msg");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->msg(), output);
  }

  // optional int64 timestamp = 8;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(8, this->timestamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tinynet.logging.LogMessageItem)
}

::google::protobuf::uint8* LogMessageItem::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tinynet.logging.LogMessageItem)
  // optional string host = 1;
  if (has_host()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->host().data(), this->host().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "host");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->host(), target);
  }

  // optional int32 pid = 2;
  if (has_pid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->pid(), target);
  }

  // optional int32 tid = 3;
  if (has_tid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->tid(), target);
  }

  // optional string file = 4;
  if (has_file()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->file().data(), this->file().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "file");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->file(), target);
  }

  // optional int32 line = 5;
  if (has_line()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->line(), target);
  }

  // optional int32 serverity = 6;
  if (has_serverity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->serverity(), target);
  }

  // optional string msg = 7;
  if (has_msg()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->msg().data(), this->msg().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "msg");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->msg(), target);
  }

  // optional int64 timestamp = 8;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(8, this->timestamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tinynet.logging.LogMessageItem)
  return target;
}

int LogMessageItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string host = 1;
    if (has_host()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->host());
    }

    // optional int32 pid = 2;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pid());
    }

    // optional int32 tid = 3;
    if (has_tid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->tid());
    }

    // optional string file = 4;
    if (has_file()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->file());
    }

    // optional int32 line = 5;
    if (has_line()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->line());
    }

    // optional int32 serverity = 6;
    if (has_serverity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->serverity());
    }

    // optional string msg = 7;
    if (has_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msg());
    }

    // optional int64 timestamp = 8;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->timestamp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogMessageItem::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LogMessageItem* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LogMessageItem*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LogMessageItem::MergeFrom(const LogMessageItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_host()) {
      set_host(from.host());
    }
    if (from.has_pid()) {
      set_pid(from.pid());
    }
    if (from.has_tid()) {
      set_tid(from.tid());
    }
    if (from.has_file()) {
      set_file(from.file());
    }
    if (from.has_line()) {
      set_line(from.line());
    }
    if (from.has_serverity()) {
      set_serverity(from.serverity());
    }
    if (from.has_msg()) {
      set_msg(from.msg());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LogMessageItem::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogMessageItem::CopyFrom(const LogMessageItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogMessageItem::IsInitialized() const {

  return true;
}

void LogMessageItem::Swap(LogMessageItem* other) {
  if (other != this) {
    std::swap(host_, other->host_);
    std::swap(pid_, other->pid_);
    std::swap(tid_, other->tid_);
    std::swap(file_, other->file_);
    std::swap(line_, other->line_);
    std::swap(serverity_, other->serverity_);
    std::swap(msg_, other->msg_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LogMessageItem::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LogMessageItem_descriptor_;
  metadata.reflection = LogMessageItem_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LogOptions::kLogtostderrFieldNumber;
const int LogOptions::kAlsologtostderrFieldNumber;
const int LogOptions::kColorlogtostderrFieldNumber;
const int LogOptions::kStderrthresholdFieldNumber;
const int LogOptions::kLogPrefixFieldNumber;
const int LogOptions::kLogbuflevelFieldNumber;
const int LogOptions::kLogbufsecsFieldNumber;
const int LogOptions::kMinloglevelFieldNumber;
const int LogOptions::kLogfileModeFieldNumber;
const int LogOptions::kVFieldNumber;
const int LogOptions::kMaxLogSizeFieldNumber;
const int LogOptions::kStopLoggingIfFullDiskFieldNumber;
#endif  // !_MSC_VER

LogOptions::LogOptions()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tinynet.logging.LogOptions)
}

void LogOptions::InitAsDefaultInstance() {
}

LogOptions::LogOptions(const LogOptions& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tinynet.logging.LogOptions)
}

void LogOptions::SharedCtor() {
  _cached_size_ = 0;
  logtostderr_ = false;
  alsologtostderr_ = false;
  colorlogtostderr_ = false;
  stderrthreshold_ = 0;
  log_prefix_ = false;
  logbuflevel_ = 0;
  logbufsecs_ = 0;
  minloglevel_ = 0;
  logfile_mode_ = 0;
  v_ = 0;
  max_log_size_ = 0;
  stop_logging_if_full_disk_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogOptions::~LogOptions() {
  // @@protoc_insertion_point(destructor:tinynet.logging.LogOptions)
  SharedDtor();
}

void LogOptions::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LogOptions::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LogOptions::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogOptions_descriptor_;
}

const LogOptions& LogOptions::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logging_2eproto();
  return *default_instance_;
}

LogOptions* LogOptions::default_instance_ = NULL;

LogOptions* LogOptions::New() const {
  return new LogOptions;
}

void LogOptions::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<LogOptions*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(logtostderr_, minloglevel_);
  }
  ZR_(logfile_mode_, stop_logging_if_full_disk_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LogOptions::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tinynet.logging.LogOptions)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool logtostderr = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &logtostderr_)));
          set_has_logtostderr();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_alsologtostderr;
        break;
      }

      // optional bool alsologtostderr = 2;
      case 2: {
        if (tag == 16) {
         parse_alsologtostderr:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &alsologtostderr_)));
          set_has_alsologtostderr();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_colorlogtostderr;
        break;
      }

      // optional bool colorlogtostderr = 3;
      case 3: {
        if (tag == 24) {
         parse_colorlogtostderr:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &colorlogtostderr_)));
          set_has_colorlogtostderr();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_stderrthreshold;
        break;
      }

      // optional int32 stderrthreshold = 4;
      case 4: {
        if (tag == 32) {
         parse_stderrthreshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &stderrthreshold_)));
          set_has_stderrthreshold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_log_prefix;
        break;
      }

      // optional bool log_prefix = 5;
      case 5: {
        if (tag == 40) {
         parse_log_prefix:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &log_prefix_)));
          set_has_log_prefix();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_logbuflevel;
        break;
      }

      // optional int32 logbuflevel = 6;
      case 6: {
        if (tag == 48) {
         parse_logbuflevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &logbuflevel_)));
          set_has_logbuflevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_logbufsecs;
        break;
      }

      // optional int32 logbufsecs = 7;
      case 7: {
        if (tag == 56) {
         parse_logbufsecs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &logbufsecs_)));
          set_has_logbufsecs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_minloglevel;
        break;
      }

      // optional int32 minloglevel = 8;
      case 8: {
        if (tag == 64) {
         parse_minloglevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &minloglevel_)));
          set_has_minloglevel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_logfile_mode;
        break;
      }

      // optional int32 logfile_mode = 9;
      case 9: {
        if (tag == 72) {
         parse_logfile_mode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &logfile_mode_)));
          set_has_logfile_mode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_v;
        break;
      }

      // optional int32 v = 10;
      case 10: {
        if (tag == 80) {
         parse_v:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &v_)));
          set_has_v();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_max_log_size;
        break;
      }

      // optional int32 max_log_size = 11;
      case 11: {
        if (tag == 88) {
         parse_max_log_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_log_size_)));
          set_has_max_log_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_stop_logging_if_full_disk;
        break;
      }

      // optional bool stop_logging_if_full_disk = 12;
      case 12: {
        if (tag == 96) {
         parse_stop_logging_if_full_disk:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &stop_logging_if_full_disk_)));
          set_has_stop_logging_if_full_disk();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tinynet.logging.LogOptions)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tinynet.logging.LogOptions)
  return false;
#undef DO_
}

void LogOptions::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tinynet.logging.LogOptions)
  // optional bool logtostderr = 1;
  if (has_logtostderr()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->logtostderr(), output);
  }

  // optional bool alsologtostderr = 2;
  if (has_alsologtostderr()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->alsologtostderr(), output);
  }

  // optional bool colorlogtostderr = 3;
  if (has_colorlogtostderr()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->colorlogtostderr(), output);
  }

  // optional int32 stderrthreshold = 4;
  if (has_stderrthreshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->stderrthreshold(), output);
  }

  // optional bool log_prefix = 5;
  if (has_log_prefix()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->log_prefix(), output);
  }

  // optional int32 logbuflevel = 6;
  if (has_logbuflevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->logbuflevel(), output);
  }

  // optional int32 logbufsecs = 7;
  if (has_logbufsecs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->logbufsecs(), output);
  }

  // optional int32 minloglevel = 8;
  if (has_minloglevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->minloglevel(), output);
  }

  // optional int32 logfile_mode = 9;
  if (has_logfile_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->logfile_mode(), output);
  }

  // optional int32 v = 10;
  if (has_v()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->v(), output);
  }

  // optional int32 max_log_size = 11;
  if (has_max_log_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->max_log_size(), output);
  }

  // optional bool stop_logging_if_full_disk = 12;
  if (has_stop_logging_if_full_disk()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->stop_logging_if_full_disk(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tinynet.logging.LogOptions)
}

::google::protobuf::uint8* LogOptions::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tinynet.logging.LogOptions)
  // optional bool logtostderr = 1;
  if (has_logtostderr()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->logtostderr(), target);
  }

  // optional bool alsologtostderr = 2;
  if (has_alsologtostderr()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->alsologtostderr(), target);
  }

  // optional bool colorlogtostderr = 3;
  if (has_colorlogtostderr()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->colorlogtostderr(), target);
  }

  // optional int32 stderrthreshold = 4;
  if (has_stderrthreshold()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->stderrthreshold(), target);
  }

  // optional bool log_prefix = 5;
  if (has_log_prefix()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->log_prefix(), target);
  }

  // optional int32 logbuflevel = 6;
  if (has_logbuflevel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->logbuflevel(), target);
  }

  // optional int32 logbufsecs = 7;
  if (has_logbufsecs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->logbufsecs(), target);
  }

  // optional int32 minloglevel = 8;
  if (has_minloglevel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->minloglevel(), target);
  }

  // optional int32 logfile_mode = 9;
  if (has_logfile_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->logfile_mode(), target);
  }

  // optional int32 v = 10;
  if (has_v()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->v(), target);
  }

  // optional int32 max_log_size = 11;
  if (has_max_log_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->max_log_size(), target);
  }

  // optional bool stop_logging_if_full_disk = 12;
  if (has_stop_logging_if_full_disk()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->stop_logging_if_full_disk(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tinynet.logging.LogOptions)
  return target;
}

int LogOptions::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool logtostderr = 1;
    if (has_logtostderr()) {
      total_size += 1 + 1;
    }

    // optional bool alsologtostderr = 2;
    if (has_alsologtostderr()) {
      total_size += 1 + 1;
    }

    // optional bool colorlogtostderr = 3;
    if (has_colorlogtostderr()) {
      total_size += 1 + 1;
    }

    // optional int32 stderrthreshold = 4;
    if (has_stderrthreshold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->stderrthreshold());
    }

    // optional bool log_prefix = 5;
    if (has_log_prefix()) {
      total_size += 1 + 1;
    }

    // optional int32 logbuflevel = 6;
    if (has_logbuflevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->logbuflevel());
    }

    // optional int32 logbufsecs = 7;
    if (has_logbufsecs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->logbufsecs());
    }

    // optional int32 minloglevel = 8;
    if (has_minloglevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->minloglevel());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 logfile_mode = 9;
    if (has_logfile_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->logfile_mode());
    }

    // optional int32 v = 10;
    if (has_v()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->v());
    }

    // optional int32 max_log_size = 11;
    if (has_max_log_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_log_size());
    }

    // optional bool stop_logging_if_full_disk = 12;
    if (has_stop_logging_if_full_disk()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogOptions::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LogOptions* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LogOptions*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LogOptions::MergeFrom(const LogOptions& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_logtostderr()) {
      set_logtostderr(from.logtostderr());
    }
    if (from.has_alsologtostderr()) {
      set_alsologtostderr(from.alsologtostderr());
    }
    if (from.has_colorlogtostderr()) {
      set_colorlogtostderr(from.colorlogtostderr());
    }
    if (from.has_stderrthreshold()) {
      set_stderrthreshold(from.stderrthreshold());
    }
    if (from.has_log_prefix()) {
      set_log_prefix(from.log_prefix());
    }
    if (from.has_logbuflevel()) {
      set_logbuflevel(from.logbuflevel());
    }
    if (from.has_logbufsecs()) {
      set_logbufsecs(from.logbufsecs());
    }
    if (from.has_minloglevel()) {
      set_minloglevel(from.minloglevel());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_logfile_mode()) {
      set_logfile_mode(from.logfile_mode());
    }
    if (from.has_v()) {
      set_v(from.v());
    }
    if (from.has_max_log_size()) {
      set_max_log_size(from.max_log_size());
    }
    if (from.has_stop_logging_if_full_disk()) {
      set_stop_logging_if_full_disk(from.stop_logging_if_full_disk());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LogOptions::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogOptions::CopyFrom(const LogOptions& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogOptions::IsInitialized() const {

  return true;
}

void LogOptions::Swap(LogOptions* other) {
  if (other != this) {
    std::swap(logtostderr_, other->logtostderr_);
    std::swap(alsologtostderr_, other->alsologtostderr_);
    std::swap(colorlogtostderr_, other->colorlogtostderr_);
    std::swap(stderrthreshold_, other->stderrthreshold_);
    std::swap(log_prefix_, other->log_prefix_);
    std::swap(logbuflevel_, other->logbuflevel_);
    std::swap(logbufsecs_, other->logbufsecs_);
    std::swap(minloglevel_, other->minloglevel_);
    std::swap(logfile_mode_, other->logfile_mode_);
    std::swap(v_, other->v_);
    std::swap(max_log_size_, other->max_log_size_);
    std::swap(stop_logging_if_full_disk_, other->stop_logging_if_full_disk_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LogOptions::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LogOptions_descriptor_;
  metadata.reflection = LogOptions_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LogReq::kBasenameFieldNumber;
const int LogReq::kItemsFieldNumber;
const int LogReq::kOptionsFieldNumber;
const int LogReq::kFlushLevelFieldNumber;
#endif  // !_MSC_VER

LogReq::LogReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tinynet.logging.LogReq)
}

void LogReq::InitAsDefaultInstance() {
  options_ = const_cast< ::tinynet::logging::LogOptions*>(&::tinynet::logging::LogOptions::default_instance());
}

LogReq::LogReq(const LogReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tinynet.logging.LogReq)
}

void LogReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  basename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  options_ = NULL;
  flush_level_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogReq::~LogReq() {
  // @@protoc_insertion_point(destructor:tinynet.logging.LogReq)
  SharedDtor();
}

void LogReq::SharedDtor() {
  if (basename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete basename_;
  }
  if (this != default_instance_) {
    delete options_;
  }
}

void LogReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LogReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogReq_descriptor_;
}

const LogReq& LogReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logging_2eproto();
  return *default_instance_;
}

LogReq* LogReq::default_instance_ = NULL;

LogReq* LogReq::New() const {
  return new LogReq;
}

void LogReq::Clear() {
  if (_has_bits_[0 / 32] & 13) {
    if (has_basename()) {
      if (basename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        basename_->clear();
      }
    }
    if (has_options()) {
      if (options_ != NULL) options_->::tinynet::logging::LogOptions::Clear();
    }
    flush_level_ = 0;
  }
  items_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LogReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tinynet.logging.LogReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string basename = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_basename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->basename().data(), this->basename().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "basename");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_items;
        break;
      }

      // repeated .tinynet.logging.LogMessageItem items = 2;
      case 2: {
        if (tag == 18) {
         parse_items:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_items()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_items;
        if (input->ExpectTag(26)) goto parse_options;
        break;
      }

      // optional .tinynet.logging.LogOptions options = 3;
      case 3: {
        if (tag == 26) {
         parse_options:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_options()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_flush_level;
        break;
      }

      // optional int32 flush_level = 4;
      case 4: {
        if (tag == 32) {
         parse_flush_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &flush_level_)));
          set_has_flush_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tinynet.logging.LogReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tinynet.logging.LogReq)
  return false;
#undef DO_
}

void LogReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tinynet.logging.LogReq)
  // optional string basename = 1;
  if (has_basename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->basename().data(), this->basename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "basename");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->basename(), output);
  }

  // repeated .tinynet.logging.LogMessageItem items = 2;
  for (int i = 0; i < this->items_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->items(i), output);
  }

  // optional .tinynet.logging.LogOptions options = 3;
  if (has_options()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->options(), output);
  }

  // optional int32 flush_level = 4;
  if (has_flush_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->flush_level(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tinynet.logging.LogReq)
}

::google::protobuf::uint8* LogReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tinynet.logging.LogReq)
  // optional string basename = 1;
  if (has_basename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->basename().data(), this->basename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "basename");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->basename(), target);
  }

  // repeated .tinynet.logging.LogMessageItem items = 2;
  for (int i = 0; i < this->items_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->items(i), target);
  }

  // optional .tinynet.logging.LogOptions options = 3;
  if (has_options()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->options(), target);
  }

  // optional int32 flush_level = 4;
  if (has_flush_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->flush_level(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tinynet.logging.LogReq)
  return target;
}

int LogReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string basename = 1;
    if (has_basename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->basename());
    }

    // optional .tinynet.logging.LogOptions options = 3;
    if (has_options()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->options());
    }

    // optional int32 flush_level = 4;
    if (has_flush_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->flush_level());
    }

  }
  // repeated .tinynet.logging.LogMessageItem items = 2;
  total_size += 1 * this->items_size();
  for (int i = 0; i < this->items_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->items(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LogReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LogReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LogReq::MergeFrom(const LogReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  items_.MergeFrom(from.items_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_basename()) {
      set_basename(from.basename());
    }
    if (from.has_options()) {
      mutable_options()->::tinynet::logging::LogOptions::MergeFrom(from.options());
    }
    if (from.has_flush_level()) {
      set_flush_level(from.flush_level());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LogReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogReq::CopyFrom(const LogReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogReq::IsInitialized() const {

  return true;
}

void LogReq::Swap(LogReq* other) {
  if (other != this) {
    std::swap(basename_, other->basename_);
    items_.Swap(&other->items_);
    std::swap(options_, other->options_);
    std::swap(flush_level_, other->flush_level_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LogReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LogReq_descriptor_;
  metadata.reflection = LogReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LogResp::kErrorCodeFieldNumber;
#endif  // !_MSC_VER

LogResp::LogResp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tinynet.logging.LogResp)
}

void LogResp::InitAsDefaultInstance() {
}

LogResp::LogResp(const LogResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tinynet.logging.LogResp)
}

void LogResp::SharedCtor() {
  _cached_size_ = 0;
  error_code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogResp::~LogResp() {
  // @@protoc_insertion_point(destructor:tinynet.logging.LogResp)
  SharedDtor();
}

void LogResp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LogResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LogResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogResp_descriptor_;
}

const LogResp& LogResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logging_2eproto();
  return *default_instance_;
}

LogResp* LogResp::default_instance_ = NULL;

LogResp* LogResp::New() const {
  return new LogResp;
}

void LogResp::Clear() {
  error_code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LogResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tinynet.logging.LogResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 error_code = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &error_code_)));
          set_has_error_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tinynet.logging.LogResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tinynet.logging.LogResp)
  return false;
#undef DO_
}

void LogResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tinynet.logging.LogResp)
  // optional int32 error_code = 1;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->error_code(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tinynet.logging.LogResp)
}

::google::protobuf::uint8* LogResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tinynet.logging.LogResp)
  // optional int32 error_code = 1;
  if (has_error_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->error_code(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tinynet.logging.LogResp)
  return target;
}

int LogResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 error_code = 1;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->error_code());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LogResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LogResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LogResp::MergeFrom(const LogResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LogResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogResp::CopyFrom(const LogResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogResp::IsInitialized() const {

  return true;
}

void LogResp::Swap(LogResp* other) {
  if (other != this) {
    std::swap(error_code_, other->error_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LogResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LogResp_descriptor_;
  metadata.reflection = LogResp_reflection_;
  return metadata;
}


// ===================================================================

LoggingRpcService::~LoggingRpcService() {}

const ::google::protobuf::ServiceDescriptor* LoggingRpcService::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LoggingRpcService_descriptor_;
}

const ::google::protobuf::ServiceDescriptor* LoggingRpcService::GetDescriptor() {
  protobuf_AssignDescriptorsOnce();
  return LoggingRpcService_descriptor_;
}

void LoggingRpcService::Log(::google::protobuf::RpcController* controller,
                         const ::tinynet::logging::LogReq*,
                         ::tinynet::logging::LogResp*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method Log() not implemented.");
  done->Run();
}

void LoggingRpcService::CallMethod(const ::google::protobuf::MethodDescriptor* method,
                             ::google::protobuf::RpcController* controller,
                             const ::google::protobuf::Message* request,
                             ::google::protobuf::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), LoggingRpcService_descriptor_);
  switch(method->index()) {
    case 0:
      Log(controller,
             ::google::protobuf::down_cast<const ::tinynet::logging::LogReq*>(request),
             ::google::protobuf::down_cast< ::tinynet::logging::LogResp*>(response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::google::protobuf::Message& LoggingRpcService::GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::tinynet::logging::LogReq::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

const ::google::protobuf::Message& LoggingRpcService::GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::tinynet::logging::LogResp::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

LoggingRpcService_Stub::LoggingRpcService_Stub(::google::protobuf::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
LoggingRpcService_Stub::LoggingRpcService_Stub(
    ::google::protobuf::RpcChannel* channel,
    ::google::protobuf::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::google::protobuf::Service::STUB_OWNS_CHANNEL) {}
LoggingRpcService_Stub::~LoggingRpcService_Stub() {
  if (owns_channel_) delete channel_;
}

void LoggingRpcService_Stub::Log(::google::protobuf::RpcController* controller,
                              const ::tinynet::logging::LogReq* request,
                              ::tinynet::logging::LogResp* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}

// @@protoc_insertion_point(namespace_scope)

}  // namespace logging
}  // namespace tinynet

// @@protoc_insertion_point(global_scope)
